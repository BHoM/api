name: APIGenerator CI/CD Pipeline

on:
  workflow_dispatch:
  schedule:
    - cron: '0 1 * * 0' # Every Sunday at 1 AM UTC
    
permissions:
  contents: write
  pull-requests: write
  actions: read

env:
  TARGET_BRANCH: automatic-api-updates
  FALLBACK_BRANCH: main
  DOTNET_VERSION: '8.0.x'
  BUILD_CONFIGURATION: Release

jobs:
  setup:
    if: github.ref == 'refs/heads/main'
    runs-on: windows-latest
    timeout-minutes: 10
    outputs:
      branch: ${{ steps.resolve_branch.outputs.branch }}
      repositories: ${{ steps.parse_repos.outputs.repositories }}
    
    steps:
    - name: Resolve branch to use
      id: resolve_branch
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        TARGET_BRANCH: ${{ env.TARGET_BRANCH }}
        FALLBACK_BRANCH: ${{ env.FALLBACK_BRANCH }}
      run: |
        $REPO = "github.com/$env:GITHUB_REPOSITORY"
        $targetBranchExists = git ls-remote --heads "https://x-access-token:$env:GITHUB_TOKEN@$REPO" $env:TARGET_BRANCH
        if ($targetBranchExists) {
          "branch=$env:TARGET_BRANCH" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        } else {
          "branch=$env:FALLBACK_BRANCH" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        }
        
    - name: Checkout main repository
      uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ steps.resolve_branch.outputs.branch }}
        fetch-depth: 0
        
    - name: Show which branch was used
      run: "echo \"Using branch: ${{ steps.resolve_branch.outputs.branch }}\""
    
    - name: Setup .NET
      uses: actions/setup-dotnet@4d6c8fcf3c8f7a60068d26b594648e99df24cee3 # v4.0.0
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@6fb02220983dee41ce7ae257b6f4d8f9bf5ed4ce # v2.0.0
    
    - name: Setup NuGet.exe for use with actions
      uses: NuGet/setup-nuget@a21f25cd3998bf370fde17e3f1b4c12c175172c9 # v2.0.0
      
    - name: Cache NuGet packages
      uses: actions/cache@ab5e6d0c87105b4c9c2047343972218f562e4319 # v4.0.1

      with:
        path: |
          ~/.nuget/packages
          ${{ github.workspace }}/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.sln', '**/packages.config') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    
    - name: Parse repository list
      id: parse_repos
      run: |
        # Check if repos file exists
        if (!(Test-Path "APIGenerator\APIGenerator\Repos.txt")) {
          Write-Error "Error: Repos.txt not found at APIGenerator\APIGenerator\Repos.txt"
          exit 1
        }
        
        # Read and validate repositories
        $validRepos = @()
        Get-Content "APIGenerator\APIGenerator\Repos.txt" | ForEach-Object {
          $repo_url = $_.Trim()
          
          # Skip empty lines and comments
          if ([string]::IsNullOrWhiteSpace($repo_url) -or $repo_url.StartsWith("#")) {
            return
          }
          
          # Validate repository URL format
          if ($repo_url -match '^https://github\.com/[^/]+/[^/]+(?:\.git)?/?$') {
            # Extract repo name from URL
            $repo_name = [System.IO.Path]::GetFileNameWithoutExtension($repo_url)
            if ($repo_name.EndsWith(".git")) {
              $repo_name = $repo_name.Substring(0, $repo_name.Length - 4)
            }
            
            $validRepos += @{
              url = $repo_url
              name = $repo_name
            }
            Write-Host "‚úì Valid repository: $repo_name ($repo_url)"
          } else {
            Write-Warning "‚ö†Ô∏è Invalid repository URL format: $repo_url"
          }
        }
        
        # Convert to JSON for matrix strategy
        $matrix = @{
          include = $validRepos
        }
        $matrixJson = $matrix | ConvertTo-Json -Compress -Depth 10
        "repositories=$matrixJson" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        
        Write-Host "Found $($validRepos.Count) valid repositories"
      shell: pwsh
    
    - name: Create Repositories directory
      run: mkdir Repositories -Force
      
  build:
    needs: setup
    if: github.ref == 'refs/heads/main'
    runs-on: windows-latest
    timeout-minutes: 90
    
    steps:
    - name: Checkout main repository
      uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ needs.setup.outputs.branch }}
        fetch-depth: 1
        
    - name: Setup .NET
      uses: actions/setup-dotnet@4d6c8fcf3c8f7a60068d26b594648e99df24cee3 # v4.0.0
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@6fb02220983dee41ce7ae257b6f4d8f9bf5ed4ce # v2.0.0
    
    - name: Setup NuGet.exe for use with actions
      uses: NuGet/setup-nuget@a21f25cd3998bf370fde17e3f1b4c12c175172c9 # v2.0.0
      
    - name: Cache NuGet packages
      uses: actions/cache@ab5e6d0c87105b4c9c2047343972218f562e4319 # v4.0.1

      with:
        path: |
          ~/.nuget/packages
          ${{ github.workspace }}/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.sln', '**/packages.config') }}-build
        restore-keys: |
          ${{ runner.os }}-nuget-build-
          ${{ runner.os }}-nuget-
          
    - name: Create Repositories directory and BHoM Assemblies folder
      run: |
        mkdir Repositories -Force
        
        # Create BHoM Assemblies directory
        $bhoMPath = "$env:ProgramData\BHoM\Assemblies"
        if (!(Test-Path $bhoMPath)) {
          mkdir $bhoMPath -Force
          Write-Host "‚úÖ Created BHoM Assemblies directory: $bhoMPath"
        } else {
          Write-Host "‚ÑπÔ∏è BHoM Assemblies directory already exists: $bhoMPath"
        }
      shell: pwsh
    
    - name: Clone all repositories
      run: |
        # Parse repository list from setup job output
        $repositoriesJson = '${{ needs.setup.outputs.repositories }}'
        $repositories = ($repositoriesJson | ConvertFrom-Json).include
        
        Write-Host "üîÑ Cloning $($repositories.Count) repositories..."
        
        $clonedRepos = @{}
        
        foreach ($repo in $repositories) {
          $repo_url = $repo.url
          $repo_name = $repo.name
          
          Write-Host "üîÑ Cloning repository: $repo_name"
          Write-Host "üìç Repository URL: $repo_url"
          
          # Clone repository with retry logic
          $maxRetries = 3
          $retryCount = 0
          $cloneSuccess = $false
          
          while ($retryCount -lt $maxRetries -and -not $cloneSuccess) {
            try {
              $retryCount++
              Write-Host "üîÑ Clone attempt $retryCount of $maxRetries"
              
              # Use shallow clone for performance
              git clone --depth 1 $repo_url "Repositories\$repo_name"
              $cloneSuccess = $true
              Write-Host "‚úÖ Successfully cloned $repo_name"
            }
            catch {
              Write-Host "‚ùå Clone attempt $retryCount failed: $($_.Exception.Message)"
              if ($retryCount -lt $maxRetries) {
                Write-Host "‚è≥ Waiting 5 seconds before retry..."
                Start-Sleep -Seconds 5
              }
            }
          }
          
          if (-not $cloneSuccess) {
            Write-Host "‚ùå Failed to clone $repo_name after $maxRetries attempts"
            continue
          }
          
          # Check if .sln file exists in base folder
          $sln_files = Get-ChildItem "Repositories\$repo_name" -Filter "*.sln" -File -ErrorAction SilentlyContinue
          if ($sln_files.Count -gt 0) {
            Write-Host "‚úÖ Found $($sln_files.Count) .sln file(s) in $repo_name"
            
            # Read dependencies if they exist
            $dependenciesPath = "Repositories\$repo_name\dependencies.txt"
            $dependencies = @()
            if (Test-Path $dependenciesPath) {
              $dependencies = Get-Content $dependenciesPath | Where-Object { 
                $_.Trim() -and -not $_.Trim().StartsWith("#") 
              } | ForEach-Object { $_.Trim() }
              Write-Host "üìã Dependencies for $repo_name`: $($dependencies -join ', ')"
            } else {
              Write-Host "‚ÑπÔ∏è No dependencies.txt found for $repo_name"
            }
            
            $clonedRepos[$repo_name] = @{
              url = $repo_url
              name = $repo_name
              dependencies = $dependencies
              hasSln = $true
            }
          } else {
            Write-Host "‚ö†Ô∏è No .sln file found in base folder of $repo_name - skipping build"
            $clonedRepos[$repo_name] = @{
              url = $repo_url
              name = $repo_name
              dependencies = @()
              hasSln = $false
            }
          }
        }
        
        # Save cloned repositories info for build ordering
        $clonedRepos | ConvertTo-Json -Depth 10 | Out-File -FilePath "cloned_repos.json" -Encoding UTF8
        Write-Host "‚úÖ Cloned $($clonedRepos.Count) repositories successfully"
      shell: pwsh
    
    - name: Determine build order using dependency analysis
      run: |
        Write-Host "üìã Analyzing dependencies and determining build order..."
        
        # Load cloned repositories data
        $clonedRepos = Get-Content "cloned_repos.json" | ConvertFrom-Json
        
        # Convert to hashtable for easier access
        $repoData = @{}
        $clonedRepos.PSObject.Properties | ForEach-Object {
          $repoData[$_.Name] = $_.Value
        }
        
        # Function to perform topological sort
        function Get-BuildOrder {
          param($repos)
          
          $buildOrder = @()
          $visited = @{}
          $visiting = @{}
          
          function Visit-Repository($repoName) {
            if ($visiting[$repoName]) {
              Write-Warning "‚ö†Ô∏è Circular dependency detected involving $repoName"
              return
            }
            
            if ($visited[$repoName]) {
              return
            }
            
            $visiting[$repoName] = $true
            
            # Visit dependencies first
            if ($repos[$repoName] -and $repos[$repoName].dependencies) {
              foreach ($dep in $repos[$repoName].dependencies) {
                if ($repos[$dep]) {
                  Visit-Repository $dep
                }
              }
            }
            
            $visiting[$repoName] = $false
            $visited[$repoName] = $true
            
            # Only add repositories that have .sln files
            if ($repos[$repoName] -and $repos[$repoName].hasSln) {
              $buildOrder += $repoName
            }
          }
          
          # Visit all repositories
          foreach ($repoName in $repos.Keys) {
            if (-not $visited[$repoName]) {
              Visit-Repository $repoName
            }
          }
          
          return $buildOrder
        }
        
        # Get the correct build order
        $buildOrder = Get-BuildOrder $repoData
        
        Write-Host "üéØ Determined build order:"
        for ($i = 0; $i -lt $buildOrder.Count; $i++) {
          Write-Host "   $($i + 1). $($buildOrder[$i])"
        }
        
        # Save build order to file
        $buildOrder | ConvertTo-Json | Out-File -FilePath "build_order.json" -Encoding UTF8
        
        Write-Host "‚úÖ Build order analysis complete"
      shell: pwsh
    
    - name: Build repositories in dependency order
      run: |
        Write-Host "üî® Starting dependency-ordered build process..."
        
        # Load build order
        $buildOrder = Get-Content "build_order.json" | ConvertFrom-Json
        $clonedRepos = Get-Content "cloned_repos.json" | ConvertFrom-Json
        
        if ($buildOrder.Count -eq 0) {
          Write-Host "‚ÑπÔ∏è No repositories with .sln files to build"
          exit 0
        }
        
        $totalRepos = $buildOrder.Count
        $builtCount = 0
        $failedRepos = @()
        
        foreach ($repoName in $buildOrder) {
          $builtCount++
          Write-Host ""
          Write-Host "üî® [$builtCount/$totalRepos] Building repository: $repoName"
          Write-Host "=" * 60
          
          if (!(Test-Path "Repositories\$repoName")) {
            Write-Host "‚ùå Repository directory not found: $repoName"
            $failedRepos += $repoName
            continue
          }
          
          Push-Location "Repositories\$repoName"
          
          try {
            # Find and process all .sln files
            $sln_files = Get-ChildItem -Filter "*.sln" -File -ErrorAction SilentlyContinue
            if ($sln_files.Count -eq 0) {
              Write-Host "‚ö†Ô∏è No .sln files found in $repoName"
              continue
            }
            
            $repoSuccess = $true
            
            foreach ($sln_file in $sln_files) {
              Write-Host "üì¶ Processing solution: $($sln_file.Name)"
              
              # Restore packages with retry logic
              $maxRetries = 3
              $retryCount = 0
              $restoreSuccess = $false
              
              while ($retryCount -lt $maxRetries -and -not $restoreSuccess) {
                try {
                  $retryCount++
                  Write-Host "üîÑ Restore attempt $retryCount of $maxRetries for $($sln_file.Name)"
                  
                  dotnet restore $sln_file.Name --verbosity minimal
                  if ($LASTEXITCODE -eq 0) {
                    $restoreSuccess = $true
                    Write-Host "‚úÖ Package restore successful for $($sln_file.Name)"
                  }
                }
                catch {
                  Write-Host "‚ùå Restore attempt $retryCount failed: $($_.Exception.Message)"
                  if ($retryCount -lt $maxRetries) {
                    Start-Sleep -Seconds 3
                  }
                }
              }
              
              if (-not $restoreSuccess) {
                Write-Host "‚ö†Ô∏è Package restore failed, trying NuGet restore..."
                nuget restore $sln_file.Name
              }
              
              # Build with dotnet first
              Write-Host "üî® Building $($sln_file.Name) with dotnet build..."
              dotnet build $sln_file.Name --configuration $env:BUILD_CONFIGURATION --no-restore --verbosity minimal
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ Successfully built $($sln_file.Name) with dotnet build"
              } else {
                Write-Host "‚ö†Ô∏è dotnet build failed for $($sln_file.Name), trying MSBuild..."
                
                # Fallback to MSBuild
                msbuild $sln_file.Name /p:Configuration=$env:BUILD_CONFIGURATION /p:Platform="Any CPU" /m /verbosity:minimal
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ Successfully built $($sln_file.Name) with MSBuild"
                } else {
                  Write-Host "‚ùå Both dotnet build and MSBuild failed for $($sln_file.Name)"
                  $repoSuccess = $false
                }
              }
              
              # Copy assemblies to BHoM folder if build was successful
              if ($LASTEXITCODE -eq 0) {
                Write-Host "üìÅ Copying assemblies to BHoM Assemblies folder..."
                $binPaths = @(
                  "bin\$env:BUILD_CONFIGURATION\net*\*.dll",
                  "*/bin\$env:BUILD_CONFIGURATION\net*\*.dll"
                )
                
                $bhoMPath = "$env:ProgramData\BHoM\Assemblies"
                $copiedCount = 0
                
                foreach ($binPattern in $binPaths) {
                  $assemblies = Get-ChildItem -Path $binPattern -Recurse -ErrorAction SilentlyContinue
                  foreach ($assembly in $assemblies) {
                    try {
                      Copy-Item -Path $assembly.FullName -Destination $bhoMPath -Force -ErrorAction SilentlyContinue
                      $copiedCount++
                    }
                    catch {
                      # Ignore copy errors - some assemblies might be in use
                    }
                  }
                }
                
                if ($copiedCount -gt 0) {
                  Write-Host "‚úÖ Copied $copiedCount assemblies to BHoM folder"
                } else {
                  Write-Host "‚ÑπÔ∏è No assemblies found to copy for $($sln_file.Name)"
                }
              }
            }
            
            if ($repoSuccess) {
              Write-Host "üéâ Successfully built all solutions in $repoName"
            } else {
              Write-Host "‚ùå Some builds failed in $repoName"
              $failedRepos += $repoName
            }
            
          } finally {
            Pop-Location
          }
        }
        
        Write-Host ""
        Write-Host "üìä Build Summary:"
        Write-Host "   Total repositories: $totalRepos"
        Write-Host "   Successfully built: $($totalRepos - $failedRepos.Count)"
        Write-Host "   Failed: $($failedRepos.Count)"
        
        if ($failedRepos.Count -gt 0) {
          Write-Host "‚ùå Failed repositories:"
          foreach ($failedRepo in $failedRepos) {
            Write-Host "   - $failedRepo"
          }
          
          # Don't fail the entire workflow for individual repository failures
          # This allows the API generation to proceed with successfully built repositories
          Write-Host "‚ö†Ô∏è Some repositories failed to build, but continuing with API generation..."
        } else {
          Write-Host "üéâ All repositories built successfully!"
        }
      shell: pwsh
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
      with:
        name: build-output-all
        path: |
          Repositories/*/bin/**
          ${{ env.ProgramData }}/BHoM/Assemblies/**
        retention-days: 1
        if-no-files-found: warn
    
  generate:
    needs: [setup, build]
    if: github.ref == 'refs/heads/main' && !cancelled()
    runs-on: windows-latest
    timeout-minutes: 30
    
    steps:
    - name: Checkout main repository
      uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608 # v4.1.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ needs.setup.outputs.branch }}
        fetch-depth: 0
        
    - name: Setup .NET
      uses: actions/setup-dotnet@4d6c8fcf3c8f7a60068d26b594648e99df24cee3 # v4.0.0
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@6fb02220983dee41ce7ae257b6f4d8f9bf5ed4ce # v2.0.0
    
    - name: Setup NuGet.exe for use with actions
      uses: NuGet/setup-nuget@a21f25cd3998bf370fde17e3f1b4c12c175172c9 # v2.0.0
      
    - name: Cache NuGet packages
      uses: actions/cache@ab5e6d0c87105b4c9c2047343972218f562e4319 # v4.0.1

      with:
        path: |
          ~/.nuget/packages
          ${{ github.workspace }}/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.sln', '**/packages.config') }}-apigen
        restore-keys: |
          ${{ runner.os }}-nuget-apigen-
          ${{ runner.os }}-nuget-
          
    - name: Download build artifacts
      uses: actions/download-artifact@c850b930e6ba138125429b7e5c93fc707a7f8427 # v4.1.4
      with:
        name: build-output-all
        path: artifacts
        
    - name: Restore build artifacts and BHoM assemblies
      run: |
        # Restore BHoM Assemblies directory
        $bhoMPath = "$env:ProgramData\BHoM\Assemblies"
        if (!(Test-Path $bhoMPath)) {
          mkdir $bhoMPath -Force
          Write-Host "‚úÖ Created BHoM Assemblies directory: $bhoMPath"
        }
        
        # Restore artifacts
        if (Test-Path "artifacts") {
          Write-Host "üìÅ Restoring build artifacts..."
          
          # Restore repository build outputs
          if (Test-Path "artifacts\Repositories") {
            Write-Host "üì¶ Restoring repository build outputs..."
            if (!(Test-Path "Repositories")) {
              mkdir "Repositories" -Force
            }
            Copy-Item -Path "artifacts\Repositories\*" -Destination "Repositories" -Recurse -Force
            Write-Host "‚úÖ Repository build outputs restored"
          }
          
          # Restore BHoM assemblies
          $artifactBhoMPath = "artifacts\$($env:ProgramData -replace ':', '')\BHoM\Assemblies"
          if (Test-Path $artifactBhoMPath) {
            Write-Host "üì¶ Restoring BHoM assemblies..."
            Copy-Item -Path "$artifactBhoMPath\*" -Destination $bhoMPath -Force -ErrorAction SilentlyContinue
            $assemblyCount = (Get-ChildItem $bhoMPath -File -ErrorAction SilentlyContinue).Count
            Write-Host "‚úÖ Restored $assemblyCount assemblies to BHoM folder"
          } else {
            Write-Host "‚ÑπÔ∏è No BHoM assemblies found in artifacts"
          }
        } else {
          Write-Host "‚ö†Ô∏è No build artifacts found - API generation may not work correctly"
        }
      shell: pwsh
    
    - name: Clean docs/oM folder
      run: |
        $docsPath = "docs\oM"
        if (Test-Path $docsPath) {
          Write-Host "üßπ Found docs/oM folder, cleaning subfolders..."
          
          # Get all subdirectories in docs/oM
          $subfolders = Get-ChildItem -Path $docsPath -Directory -ErrorAction SilentlyContinue
          
          if ($subfolders.Count -gt 0) {
            foreach ($folder in $subfolders) {
              Write-Host "üóëÔ∏è Removing subfolder: $($folder.Name)"
              Remove-Item -Path $folder.FullName -Recurse -Force -ErrorAction SilentlyContinue
            }
            Write-Host "‚úÖ Successfully removed $($subfolders.Count) subfolders from docs/oM"
          } else {
            Write-Host "‚ÑπÔ∏è No subfolders found in docs/oM"
          }
        } else {
          Write-Host "‚ÑπÔ∏è docs/oM folder not found, skipping cleanup"
        }
      shell: pwsh
    
    - name: Compile APIGenerator solution
      run: |
        Write-Host "üî® Compiling APIGenerator.sln"
        
        # Check if the solution file exists
        if (!(Test-Path "APIGenerator\APIGenerator.sln")) {
          Write-Error "‚ùå APIGenerator.sln not found at APIGenerator\APIGenerator.sln"
          exit 1
        }
        
        # Restore packages with retry logic
        $maxRetries = 3
        $retryCount = 0
        $restoreSuccess = $false
        
        while ($retryCount -lt $maxRetries -and -not $restoreSuccess) {
          try {
            $retryCount++
            Write-Host "üîÑ Package restore attempt $retryCount of $maxRetries"
            
            dotnet restore "APIGenerator\APIGenerator.sln" --verbosity minimal
            if ($LASTEXITCODE -eq 0) {
              $restoreSuccess = $true
              Write-Host "‚úÖ Package restore successful"
            }
          }
          catch {
            Write-Host "‚ùå Restore attempt $retryCount failed"
            if ($retryCount -lt $maxRetries) {
              Start-Sleep -Seconds 3
            }
          }
        }
        
        if (-not $restoreSuccess) {
          Write-Host "‚ö†Ô∏è dotnet restore failed, trying MSBuild restore..."
          msbuild "APIGenerator\APIGenerator.sln" -t:Restore /p:Configuration=$env:BUILD_CONFIGURATION /verbosity:minimal
        }
        
        # Build the solution
        Write-Host "üî® Building APIGenerator.sln with dotnet build"
        dotnet build "APIGenerator\APIGenerator.sln" --configuration $env:BUILD_CONFIGURATION --no-restore --verbosity minimal
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "‚ö†Ô∏è dotnet build failed, trying MSBuild..."
          
          msbuild "APIGenerator\APIGenerator.sln" /p:Configuration=$env:BUILD_CONFIGURATION /p:Platform="Any CPU" /m /verbosity:minimal
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "‚ùå Both dotnet build and MSBuild failed for APIGenerator.sln"
            exit 1
          } else {
            Write-Host "‚úÖ Successfully built APIGenerator.sln with MSBuild"
          }
        } else {
          Write-Host "‚úÖ Successfully built APIGenerator.sln with dotnet build"
        }
      shell: pwsh
    
    - name: Find and run APIGenerator executable
      run: |
        Write-Host "üîç Looking for APIGenerator executable..."
        
        # Look for the executable in common build output locations
        $possible_paths = @(
          "APIGenerator\APIGenerator\bin\$env:BUILD_CONFIGURATION\net*\APIGenerator.exe",
          "APIGenerator\bin\$env:BUILD_CONFIGURATION\net*\APIGenerator.exe"
        )
        
        $exe_path = $null
        foreach ($pattern in $possible_paths) {
          Write-Host "üîç Searching pattern: $pattern"
          $found_files = Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue
          if ($found_files) {
            $exe_path = $found_files[0].FullName
            Write-Host "‚úÖ Found executable: $exe_path"
            break
          }
        }
        
        # If no .exe found, try using dotnet run
        if ([string]::IsNullOrEmpty($exe_path)) {
          Write-Host "‚ö†Ô∏è No executable found, trying dotnet run..."
          
          if (Test-Path "APIGenerator\APIGenerator.csproj") {
            Write-Host "üöÄ Running APIGenerator via dotnet run (APIGenerator\APIGenerator.csproj)..."
            Push-Location "APIGenerator"
            dotnet run --project APIGenerator.csproj --configuration $env:BUILD_CONFIGURATION --verbosity minimal
            Pop-Location
          } elseif (Test-Path "APIGenerator\APIGenerator\APIGenerator.csproj") {
            Write-Host "üöÄ Running APIGenerator via dotnet run (APIGenerator\APIGenerator\APIGenerator.csproj)..."
            Push-Location "APIGenerator"
            dotnet run --project APIGenerator\APIGenerator.csproj --configuration $env:BUILD_CONFIGURATION --verbosity minimal
            Pop-Location
          } else {
            Write-Error "‚ùå Could not find APIGenerator.csproj file"
            exit 1
          }
        } else {
          Write-Host "üöÄ Running APIGenerator executable..."
          
          # Run the executable with timeout
          $process = Start-Process -FilePath $exe_path -NoNewWindow -PassThru -Wait
          
          if ($process.ExitCode -eq 0) {
            Write-Host "‚úÖ APIGenerator completed successfully"
          } else {
            Write-Error "‚ùå APIGenerator failed with exit code: $($process.ExitCode)"
            exit 1
          }
        }
      shell: pwsh
    
    - name: Commit and push changes
      run: |
        # Configure git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        # Create and checkout new branch (or switch if exists)
        $branch_name = "${{ env.TARGET_BRANCH }}"
        $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        
        Write-Host "üîÑ Switching to branch: $branch_name"
        git checkout $branch_name 2>$null || git checkout -b $branch_name

        # Add all changes (including new files and directories)
        git add -A

        # Check if there are any changes to commit
        $changes = git status --porcelain
        if ($changes) {
          Write-Host "üìù Changes detected, preparing commit..."
          
          # Show what changed
          Write-Host "üìã Changed files:"
          git status --porcelain | ForEach-Object { Write-Host "   $_" }
          
          # Commit with detailed message
          $commitMessage = "APIGenerator workflow results - $timestamp`n`n- Generated API documentation from latest repository builds`n- Workflow run: ${{ github.run_number }}`n- Triggered by: ${{ github.event_name }}`n- Repository count: Built from multiple repositories in parallel"
          
          git commit -m $commitMessage
          Write-Host "‚úÖ Committed changes successfully"

          # Push the branch with retry logic
          $maxRetries = 3
          $retryCount = 0
          $pushSuccess = $false
          
          while ($retryCount -lt $maxRetries -and -not $pushSuccess) {
            try {
              $retryCount++
              Write-Host "üîÑ Push attempt $retryCount of $maxRetries"
              
              git push origin $branch_name
              $pushSuccess = $true
              Write-Host "‚úÖ Successfully pushed changes to branch: $branch_name"
            }
            catch {
              Write-Host "‚ùå Push attempt $retryCount failed"
              if ($retryCount -lt $maxRetries) {
                Write-Host "‚è≥ Waiting 5 seconds before retry..."
                Start-Sleep -Seconds 5
                
                # Try to pull any remote changes first
                git pull origin $branch_name --rebase 2>$null || $true
              }
            }
          }
          
          if (-not $pushSuccess) {
            Write-Error "‚ùå Failed to push changes after $maxRetries attempts"
            exit 1
          }

          # Handle pull request creation/update
          Write-Host "üîç Checking for existing pull request..."
          $existingPr = gh pr list --head $branch_name --base main --json number --jq '.[0].number' 2>$null
          
          if ($existingPr -and $existingPr -ne "null" -and $existingPr -ne "") {
            Write-Host "üìù PR already exists (#$existingPr), adding update comment..."
            $prComment = "ü§ñ **Automated API Documentation Update**`n`nüìÖ **Updated:** $timestamp`nüî¢ **Workflow Run:** #${{ github.run_number }}`nüöÄ **Trigger:** ${{ github.event_name }}`n`nThe API documentation has been regenerated from the latest repository builds and pushed to this branch."
            gh pr comment $existingPr --body $prComment
            Write-Host "‚úÖ Comment added to existing PR #$existingPr"
          } else {
            Write-Host "üìù Creating new pull request..."
            $prTitle = "ü§ñ API Documentation Updates - $timestamp"
            $prBody = "## ü§ñ Automated API Documentation Updates`n`nThis pull request contains automatically generated API documentation updates.`n`n### üìã Details`n- **Generated:** $timestamp`n- **Workflow Run:** #${{ github.run_number }}`n- **Triggered by:** ${{ github.event_name }}`n- **Branch:** $branch_name`n`n### üîÑ What's Updated`n- API documentation regenerated from latest repository builds`n- Documentation processed with dependency-aware sequential building`n- All repositories with .sln files were built and processed`n`n### ‚úÖ Ready for Review`nThis PR is ready for review and can be merged when approved."
            
            gh pr create --title $prTitle --body $prBody --head $branch_name --base main
            Write-Host "‚úÖ Pull request created successfully"
          }
        } else {
          Write-Host "‚ÑπÔ∏è No changes to commit - documentation is up to date"
        }
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
